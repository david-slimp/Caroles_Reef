// /src/ui/FishCollection.ts

import { SavedFish } from '../utils/fishStorage';
import { gameState, type TankFish } from '../state/GameState';
import { toast } from './toast';
// Helper function to compute max age from constitution
const computeMaxAgeSeconds = (constitution: number): number => {
  // Base age is 5 minutes (300 seconds) + 0-5 minutes random + 0-5 minutes per constitution point
  return 300 + (Math.random() * 300) + (constitution * 300);
};

// Utility function for fish spawning
const rand = (a: number, b: number) => Math.random() * (b - a) + a;

const FISH_COLLECTION_ID = 'fishCollectionPanel';

export default class FishCollection {
  private panel: HTMLElement | null = null;
  private onSelectFish: ((fishData: any) => void) | null = null;
  private sortColumn: string | null = null;
  private sortDirection: 'asc' | 'desc' = 'asc';
  private unsubscribe: (() => void) | null = null;
  
  constructor() {
    this.initializeUI();
  }
  
  private initializeUI(): void {
    // Create the panel if it doesn't exist
    if (!document.getElementById(FISH_COLLECTION_ID)) {
      this.panel = document.createElement('div');
      this.panel.id = FISH_COLLECTION_ID;
      this.panel.className = 'panel';
      this.panel.style.display = 'none';
      
      // Add panel to the document
      const uiContainer = document.getElementById('ui') || document.body;
      uiContainer.appendChild(this.panel);
      
      // Initial render
      this.render();
      
      // Set up event listeners
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && this.panel?.style.display === 'block') {
          this.hide();
        }
      });
      
      // Close when clicking outside
      this.panel.addEventListener('click', (e) => {
        if (e.target === this.panel) {
          this.hide();
        }
      });

      // Set up event delegation for fish collection interactions
      this.panel.addEventListener('click', (e) => {
        const target = e.target as HTMLElement;
        
        // Handle fish row click
        const fishRow = target.closest('.fish-row');
        if (fishRow) {
          const fishId = fishRow.getAttribute('data-fish-id');
          if (fishId) {
            const fish = this.getSavedFish().find(f => f.id === fishId);
            if (fish) {
              if (this.onSelectFish) {
                this.onSelectFish(fish);
              }
            }
          }
        }
        
        // Handle spawn button click
        const spawnBtn = target.closest('.spawn-fish-btn');
        if (spawnBtn) {
          e.stopPropagation();
          const fishId = spawnBtn.getAttribute('data-fish-id');
          if (fishId) {
            const fish = this.getSavedFish().find(f => f.id === fishId);
            if (fish) {
              this.spawnFishFromData(fish);
            }
          }
        }
        
        // Handle delete button click
        const deleteBtn = target.closest('.delete-fish-btn');
        if (deleteBtn) {
          e.stopPropagation();
          const fishId = deleteBtn.getAttribute('data-fish-id');
          if (fishId && confirm('Are you sure you want to delete this fish?')) {
            this.removeFish(fishId);
            this.render();
          }
        }
      });

      // Subscribe to game state changes
      this.setupGameStateSubscription();
    }
  }

  private setupGameStateSubscription(): void {
    // Unsubscribe from previous subscription if it exists
    if (this.unsubscribe) {
      console.log('[FishCollection] Removing previous game state subscription');
      this.unsubscribe();
      this.unsubscribe = null;
    }

    // Subscribe to game state changes
    if ((window as any).gameState?.subscribe) {
      console.log('[FishCollection] Setting up game state subscription');
      this.unsubscribe = (window as any).gameState.subscribe((state: any) => {
        this.logStateChange(state, 'subscription');
        // Only refresh if the panel is visible
        if (this.panel?.style.display === 'block') {
          console.log('[FishCollection] Game state updated, refreshing collection');
          this.render();
        }
      });
      
      // Log initial state
      try {
        const currentState = (window as any).gameState.getState();
        this.logStateChange(currentState, 'initial');
      } catch (e) {
        console.error('[FishCollection] Error getting initial game state:', e);
      }
    } else {
      console.warn('[FishCollection] gameState.subscribe not available');
    }
  }

  /**
   * Clean up resources when the collection is no longer needed
   */
  public destroy(): void {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
    }
    
    // Remove the panel from the DOM
    if (this.panel && this.panel.parentNode) {
      this.panel.parentNode.removeChild(this.panel);
      this.panel = null;
    }
  }
  
  public show(onSelectFish?: (fishData: any) => void): void {
    try {
      console.log('FishCollection.show() called');
      
      if (!this.panel) {
        console.log('Initializing panel...');
        this.initializeUI();
      }
      
      if (this.panel) {
        console.log('Panel found, showing...');
        this.onSelectFish = onSelectFish || null;
        
        // Ensure we're subscribed to game state changes
        this.setupGameStateSubscription();
        
        // Force a refresh to ensure we have the latest data
        this.render();
        this.panel.style.display = 'block';
        console.log('Panel should now be visible');
      } else {
        console.error('Failed to initialize panel');
      }
    } catch (error) {
      console.error('Error in FishCollection.show():', error);
    }
  }
  
  public hide(): void {
    this.panel!.style.display = 'none';
    this.onSelectFish = null;
  }
  
  /**
   * Check if the collection panel is currently visible
   */
  public isVisible(): boolean {
    return this.panel ? this.panel.style.display === 'block' : false;
  }
  
  /**
   * Render the collection panel
   */
  /**
   * Sort fish collection based on current sort column and direction
   */
  private sortFishCollection(fishList: SavedFish[]): SavedFish[] {
    if (!this.sortColumn) return fishList;

    console.log(`Sorting by ${this.sortColumn} (${this.sortDirection})`);
    
    // Debug: Log the first few fish with their properties
    console.log('Sample fish data:', fishList.slice(0, 3).map(f => ({
      name: f.name,
      fishData: {
        ...f.fishData,
        // Only include relevant properties to keep the log clean
        ...(this.sortColumn === 'speed' && { speed: f.fishData.speed }),
        ...(this.sortColumn === 'sense' && { senseGene: f.fishData.senseGene }),
        ...(this.sortColumn === 'hue' && { colorHue: f.fishData.colorHue })
      }
    })));
    
    const sorted = [...fishList].sort((a, b) => {
      let valueA: any;
      let valueB: any;
      let isNumeric = false;

      // Handle different column types
      switch (this.sortColumn) {
        case 'name':
          valueA = a.name?.toLowerCase() || '';
          valueB = b.name?.toLowerCase() || '';
          break;
        case 'id':
          valueA = a.id;
          valueB = b.id;
          break;
        case 'age':
          valueA = Number(a.fishData.age || 0);
          valueB = Number(b.fishData.age || 0);
          isNumeric = true;
          break;
        case 'size':
          valueA = Number(a.fishData.size || 0);
          valueB = Number(b.fishData.size || 0);
          isNumeric = true;
          break;
        case 'speed':
          // Debug: Log the entire fish data structure for the first fish
          if (a.fishData) {
            console.log('Fish data structure for speed sort:', {
              name: a.name,
              fishData: a.fishData,
              speed: a.fishData.speed,
              speedType: typeof a.fishData.speed,
              allNumericProperties: Object.entries(a.fishData)
                .filter(([_, v]) => typeof v === 'number')
                .map(([k, v]) => `${k}: ${v} (${typeof v})`)
            });
          }
          
          // Try to get speed value from different possible locations
          const getSpeed = (fish: any): number => {
            // Check direct property
            if (typeof fish.fishData.speed === 'number') return fish.fishData.speed;
            
            // Check for other possible speed properties
            const possibleSpeedProps = ['movementSpeed', 'speedValue', 'baseSpeed', 'spd'];
            for (const prop of possibleSpeedProps) {
              if (typeof fish.fishData[prop] === 'number') return fish.fishData[prop];
            }
            
            // Default to 0 if no speed found
            return 0;
          };
          
          valueA = getSpeed(a);
          valueB = getSpeed(b);
          
          console.log(`Sorting speeds - ${a.name}: ${valueA}, ${b.name}: ${valueB}`);
          isNumeric = true;
          break;
        case 'sense':
          valueA = Number(a.fishData.senseGene || 0);
          valueB = Number(b.fishData.senseGene || 0);
          isNumeric = true;
          break;
        case 'hue':
          // Handle hue values (0-360)
          valueA = Number(a.fishData.colorHue || 0);
          valueB = Number(b.fishData.colorHue || 0);
          isNumeric = true;
          break;
        case 'fins':
          valueA = a.fishData.finShape?.toLowerCase() || '';
          valueB = b.fishData.finShape?.toLowerCase() || '';
          break;
        case 'pattern':
          valueA = a.fishData.patternType?.toLowerCase() || '';
          valueB = b.fishData.patternType?.toLowerCase() || '';
          break;
        default:
          return 0;
      }

      // Compare values
      let comparison = 0;
      if (isNumeric) {
        // For numeric comparisons, ensure we're comparing numbers
        comparison = valueA - valueB;
      } else {
        // For string comparisons
        if (valueA > valueB) comparison = 1;
        else if (valueA < valueB) comparison = -1;
      }

      // Apply sort direction
      const result = this.sortDirection === 'asc' ? comparison : -comparison;
      
      // Debug log
      if (this.sortColumn === 'speed') {
        console.log(`Comparing speed: ${a.fishData.speed} vs ${b.fishData.speed} = ${result}`);
      } else if (this.sortColumn === 'sense') {
        console.log(`Comparing sense: ${a.fishData.senseGene} vs ${b.fishData.senseGene} = ${result}`);
      } else if (this.sortColumn === 'hue') {
        console.log(`Comparing hue: ${a.fishData.colorHue} vs ${b.fishData.colorHue} = ${result}`);
      }
      
      return result;
    });
    
    // Debug log the sorted order
    if (this.sortColumn === 'speed') {
      console.log('Sorted speed values:', sorted.map(f => ({
        name: f.name,
        speed: f.fishData.speed,
        speedType: typeof f.fishData.speed,
        rawSpeed: f.fishData.speed
      })));
    } else if (this.sortColumn === 'sense') {
      console.log('Sorted order:', sorted.map(f => ({
        name: f.name,
        senseGene: f.fishData.senseGene,
        senseType: typeof f.fishData.senseGene
      })));
    }
    
    return sorted;
  }

  /**
   * Handle column header click for sorting
   */
  private handleSort(column: string): void {
    console.log(`handleSort called for column: ${column}`);
    
    if (this.sortColumn === column) {
      // Toggle sort direction if clicking the same column
      this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
    } else {
      // New column, default to ascending
      this.sortColumn = column;
      this.sortDirection = 'asc';
    }
    
    // Debug: Log the fish data structure for the first few fish
    const fishList = this.getSavedFish();
    console.log('Fish data structure sample:', fishList.slice(0, 3).map(fish => ({
      name: fish.name,
      fishData: {
        ...Object.entries(fish.fishData).reduce((acc, [key, value]) => {
          // Only include numeric or relevant properties to keep the log clean
          if (typeof value === 'number' || key === 'speed' || key === 'senseGene' || key === 'colorHue') {
            acc[key] = value;
          }
          return acc;
        }, {} as Record<string, any>)
      }
    })));
    
    // Debug: Log the first few fish's values for the current column
    if (column === 'speed' || column === 'sense' || column === 'hue') {
      console.log(`First 5 fish ${column} values:`, fishList.slice(0, 5).map(f => {
        const value = column === 'sense' ? f.fishData.senseGene :
                     column === 'hue' ? f.fishData.colorHue :
                     f.fishData.speed;
        return {
          name: f.name,
          [column]: value,
          type: typeof value,
          rawValue: value
        };
      }));
    }
    
    this.render();
  }

  private createFishCard(fish: SavedFish): string {
    const fishData = fish.fishData || fish;
    const fishId = fish.id || `fish-${Date.now()}`;
    const name = fish.name || 'Unnamed Fish';
    const hue = fishData.colorHue || 0;
    const size = fishData.size || 2;
    const pattern = fishData.patternType || 'solid';
    const fins = fishData.finShape || 'normal';
    const isShiny = fishData.shiny || false;
    
    return `
      <tr class="fish-row" data-fish-id="${fishId}">
        <td class="fish-name">
          <div class="fish-name-cell">
            <span class="fish-icon" style="filter: hue-rotate(${hue}deg)">üê†</span>
            <span class="name editable" data-fish-id="${fishId}">${name}</span>
            ${isShiny ? '‚ú®' : ''}
          </div>
        </td>
        <td>${size.toFixed(1)}</td>
        <td>${hue}¬∞</td>
        <td><span class="color-swatch" style="background-color: hsl(${hue}, 80%, 50%)"></span></td>
        <td>${fins}</td>
        <td>${pattern}</td>
        <td class="actions">
          <button class="btn-spawn spawn-fish-btn" data-fish-id="${fishId}" title="Spawn in tank">
            <span>+</span>
          </button>
          <button class="btn-delete delete-fish-btn" data-fish-id="${fishId}" title="Delete fish">
            <span>√ó</span>
          </button>
        </td>
      </tr>
    `;
  }

  public render(): void {
    if (!this.panel) {
      console.warn('[FishCollection] Cannot render: panel not initialized');
      return;
    }
    
    const fishList = this.getSavedFish();
    console.log(`[FishCollection] Rendering ${fishList.length} fish in collection`);
    const sortedFish = this.sortFishCollection(fishList);
    
    this.panel.innerHTML = `
      <style>
        .fish-collection-table {
          width: 100%;
          border-collapse: collapse;
          font-size: 13px;
          margin-top: 10px;
        }
        
        .fish-collection-table th {
          text-align: left;
          padding: 8px 12px;
          background: rgba(0,0,0,0.2);
          border-bottom: 2px solid rgba(255,255,255,0.1);
          font-weight: 600;
          color: #ccc;
          position: sticky;
          top: 0;
          user-select: none;
        }
        
        .sortable {
          cursor: pointer;
          transition: background-color 0.2s;
        }
        
        .sortable:hover {
          background-color: rgba(255, 255, 255, 0.1);
        }
        
        .fish-collection-table td {
          padding: 6px 12px;
          border-bottom: 1px solid rgba(255,255,255,0.05);
          vertical-align: middle;
        }
        
        .fish-row:hover {
          background: rgba(255,255,255,0.05);
        }
        
        .fish-name {
          min-width: 150px;
        }
        
        .name.editable {
          cursor: pointer;
          padding: 2px 4px;
          border-radius: 3px;
          transition: background-color 0.2s;
        }
        
        .name.editable:hover {
          background-color: rgba(255, 255, 255, 0.1);
        }
        
        .fish-name-input {
          background: rgba(255, 255, 255, 0.1);
          border: 1px solid rgba(255, 255, 255, 0.2);
          color: white;
          padding: 2px 4px;
          border-radius: 3px;
          font-family: inherit;
          font-size: inherit;
          outline: none;
        }
        
        .fish-name-cell {
          display: flex;
          align-items: center;
          gap: 8px;
        }
        
        .fish-icon {
          display: inline-flex;
          opacity: 0.8;
        }
        
        .color-swatch {
          display: inline-block;
          width: 16px;
          height: 16px;
          border-radius: 3px;
          border: 1px solid rgba(255,255,255,0.2);
          vertical-align: middle;
        }
        
        .indicators {
          margin-left: 4px;
          color: #ffcc00;
        }
        
        .btn-add, .btn-delete {
          background: none;
          border: 1px solid rgba(255,255,255,0.2);
          color: #fff;
          width: 24px;
          height: 24px;
          border-radius: 4px;
          cursor: pointer;
          display: inline-flex;
          align-items: center;
          justify-content: center;
          padding: 0;
          font-size: 14px;
          line-height: 1;
        }
        
        .btn-add:hover {
          background: rgba(100, 200, 100, 0.2);
          border-color: #6c6;
        }
        
        .btn-delete:hover {
          background: rgba(200, 100, 100, 0.2);
          border-color: #c66;
        }
        
        .fish-stats-row {
          display: flex;
          justify-content: space-between;
          margin-top: 8px;
        }
      </style>
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <h3>My Fish Collection <span style="font-size: 0.8em; opacity: 0.8;">(${sortedFish.length} fish)</span></h3>
        <button id="closeCollection" style="background: none; border: none; color: #fff; font-size: 20px; cursor: pointer;">&times;</button>
      </div>
      <style>
        .table-wrapper {
          max-height: 70vh;
          overflow: auto;
          border: 1px solid rgba(255,255,255,0.1);
          border-radius: 4px;
        }
        
        .fish-collection-table {
          width: 100%;
          min-width: 1000px;
          table-layout: fixed;
        }
        
        .fish-collection-table th,
        .fish-collection-table td {
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }
        
        .fish-actions {
          display: flex;
          gap: 4px;
          justify-content: flex-end;
        }
        
        .fish-id {
          font-family: monospace;
          max-width: 150px;
        }
      </style>
      <div class="table-wrapper">
        <table class="fish-collection-table">
          <thead>
            <tr>
              <th style="width: 40px;">+</th>
              <th style="min-width: 120px;" class="sortable" data-column="name">
                Name ${this.sortColumn === 'name' ? (this.sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}
              </th>
              <th style="min-width: 120px;" class="sortable" data-column="id">
                ID ${this.sortColumn === 'id' ? (this.sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}
              </th>
              <th style="width: 50px;" class="sortable" data-column="age">
                Age ${this.sortColumn === 'age' ? (this.sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}
              </th>
              <th style="width: 50px;" class="sortable" data-column="size">
                Size ${this.sortColumn === 'size' ? (this.sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}
              </th>
              <th style="width: 60px;" class="sortable" data-column="speed">
                Speed ${this.sortColumn === 'speed' ? (this.sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}
              </th>
              <th style="width: 60px;" class="sortable" data-column="sense">
                Sense ${this.sortColumn === 'sense' ? (this.sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}
              </th>
              <th style="width: 50px;" class="sortable" data-column="hue">
                Hue ${this.sortColumn === 'hue' ? (this.sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}
              </th>
              <th style="width: 40px;">Color</th>
              <th style="min-width: 80px;" class="sortable" data-column="fins">
                Fins ${this.sortColumn === 'fins' ? (this.sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}
              </th>
              <th style="min-width: 80px;" class="sortable" data-column="pattern">
                Pattern ${this.sortColumn === 'pattern' ? (this.sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ''}
              </th>
              <th style="width: 40px;">√ó</th>
            </tr>
          </thead>
          <tbody>
            ${sortedFish.length > 0 ? 
              sortedFish.map(fish => this.createFishCard(fish)).join('') : 
              `<tr><td colspan="11" class="no-fish">No fish in your collection yet. Select a fish and click "Save to Collection".</td></tr>`
            }
          </tbody>
        </table>
      </div>
      <div class="collection-actions">
        <button id="closeCollectionBtn">Close</button>
      </div>
    `;
    
    // Add event listeners
    document.getElementById('closeCollection')?.addEventListener('click', () => this.hide());
    document.getElementById('closeCollectionBtn')?.addEventListener('click', () => this.hide());
    
    // Add sort handlers to column headers
    this.panel?.querySelectorAll('.sortable').forEach(header => {
      header.addEventListener('click', (e) => {
        const column = (e.currentTarget as HTMLElement).getAttribute('data-column');
        if (column) {
          this.handleSort(column);
        }
      });
      
      // Add hover effect
      header.addEventListener('mouseenter', () => {
        (header as HTMLElement).style.cursor = 'pointer';
        (header as HTMLElement).style.textDecoration = 'underline';
      });
      
      header.addEventListener('mouseleave', () => {
        (header as HTMLElement).style.textDecoration = 'none';
      });
    });
    
    // Add event delegation for all interactive elements
    this.panel?.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      
      // Handle delete button clicks
      const deleteBtn = target.closest('.delete-fish-btn');
      if (deleteBtn) {
        e.preventDefault();
        e.stopPropagation();
        const fishId = deleteBtn.getAttribute('data-fish-id');
        if (fishId) {
          if (confirm('Are you sure you want to delete this fish?')) {
            this.removeFish(fishId);
            this.render(); // Refresh the collection after deletion
          }
        }
        return;
      }
      
      // Handle spawn button clicks
      const spawnBtn = target.closest('.spawn-fish-btn');
      if (spawnBtn) {
        e.preventDefault();
        e.stopPropagation();
        const fishId = spawnBtn.getAttribute('data-fish-id');
        if (fishId) {
          const fish = this.getSavedFish().find(f => f.id === fishId);
          if (fish) {
            this.spawnFishFromData(fish);
          }
        }
        return;
      }
      
      // Handle fish row clicks (for selection)
      const fishRow = target.closest('.fish-row');
      if (fishRow) {
        e.stopPropagation();
        const fishId = fishRow.getAttribute('data-fish-id');
        if (fishId && this.onSelectFish) {
          const fish = this.getSavedFish().find(f => f.id === fishId);
          if (fish) {
            this.onSelectFish(fish);
          }
        }
        return;
      }
      
      // Handle name clicks for editing
      const nameElement = target.closest('.name.editable') as HTMLElement;
      if (nameElement) {
        e.stopPropagation();
        const fishId = nameElement.getAttribute('data-fish-id');
        if (fishId) {
          this.startRenamingFish(fishId, nameElement);
        }
      }
          if (Array.isArray(state.fishCollection)) {
            fishCollection = state.fishCollection;
            console.log('[FishCollection] Using fishCollection from state');
          } else if (Array.isArray(state.fish)) {
            fishCollection = state.fish;
            console.log('[FishCollection] Using fish array from state');
          } else if (state.gameState?.fish) {
            fishCollection = state.gameState.fish;
            console.log('[FishCollection] Using fish from gameState.fish');
          }
          
          // Ensure we have an array
          fishCollection = Array.isArray(fishCollection) ? fishCollection : [];
          
          // Log the current state of the collection
          console.groupCollapsed(`[FishCollection] Loaded ${fishCollection.length} fish from gameState`);
          console.log('Game State Structure:', {
            source: 'gameState',
            hasFishCollection: Array.isArray(state.fishCollection),
            hasFishArray: Array.isArray(state.fish),
            hasGameStateFish: Array.isArray(state.gameState?.fish),
            fishCount: fishCollection.length,
            fishIds: fishCollection.slice(0, 10).map((f: any) => ({
              id: f.id || f.fishData?.id || 'unknown-id',
              name: f.name || f.fishData?.name || 'Unnamed',
              source: f.fishData ? 'fishData' : 'direct'
            })),
            hasMore: fishCollection.length > 10 ? fishCollection.length - 10 : 0
          });
          console.groupEnd();
          
          // Make sure each fish has the expected structure
          return fishCollection.map(fish => ({
            ...fish,
            // Ensure fishData exists and has the fish properties
            fishData: {
              ...(fish.fishData || {}),
              ...fish // Include top-level properties as fallback
            }
          }));
        } catch (error) {
          console.error('[FishCollection] Error getting fish from gameState:', error);
          // Continue to fallback
        }
      }
      
      // Fallback to localStorage if gameState isn't available or fails
      try {
        const saved = localStorage.getItem('caroles_reef_saved_fish');
        if (!saved) return [];
        
        const parsed = JSON.parse(saved);
        const fishCollection = Array.isArray(parsed) ? parsed : [];
        
        console.warn('[FishCollection] Using fallback localStorage data', {
          source: 'localStorage',
          fishCount: fishCollection.length,
          fishIds: fishCollection.map((f: any) => f.id || 'unknown-id').slice(0, 10), // Limit to first 10 for logging
          hasMore: fishCollection.length > 10 ? fishCollection.length - 10 : 0
        });
        
        return fishCollection;
      } catch (error) {
        console.error('[FishCollection] Error parsing localStorage fish data:', error);
        return [];
      }
    } catch (error) {
      console.error('[FishCollection] Unexpected error in getSavedFish:', error);
      return [];
    }
  }

  /**
   * Log state changes for debugging
   */
  private logStateChange(state: any, source: string): void {
    if (!state) return;
    
    console.group(`[FishCollection] Game State Update (${source})`);
    
    const fishCollection = state.fishCollection || [];
    console.log('Current fish collection:', {
      count: fishCollection.length,
      fishIds: fishCollection.map((f: any) => f?.id || 'unknown-id').slice(0, 10), // Limit to first 10
      hasMore: fishCollection.length > 10 ? fishCollection.length - 10 : 0
    });
    
    // Only log full state in development
    if (process.env.NODE_ENV === 'development') {
      console.log('Full state:', state);
    }
    
    console.groupEnd();
  }
  
  private refreshCollection(): void {
    if (this.panel) {
      this.render();
    }
  }
  
  /**
   * Get the list of saved fish from game state or localStorage
   */
  private getSavedFish(): SavedFish[] {
    try {
      // Try to get from gameState first
      if ((window as any).gameState?.getState) {
        const state = (window as any).gameState.getState();
        if (Array.isArray(state?.fishCollection)) {
          return state.fishCollection as SavedFish[];
        }
      }
      
      // Fall back to localStorage
      const saved = localStorage.getItem('caroles_reef_saved_fish');
      return saved ? JSON.parse(saved) : [];
    } catch (error) {
      console.error('Error getting saved fish:', error);
      return [];
    }
  }

  /**
   * Spawn a fish from saved data into the tank
   */
  private spawnFishFromData(fishData: any): boolean {
    try {
      if (!fishData) return false;
      
      // Use the fish data directly or extract from fishData.fishData if it exists
      const fishToSpawn = fishData.fishData || fishData;
      
      // Ensure we have a valid position to spawn the fish
      const x = fishToSpawn.x || Math.random() * window.innerWidth;
      const y = fishToSpawn.y || Math.random() * window.innerHeight;
      
      // Create a new fish in the tank
      if ((window as any).spawnFish) {
        const newFish = {
          ...fishToSpawn,
          x,
          y,
          // Ensure we have a unique ID for the new fish
          id: `fish-${Date.now()}`,
          // Mark as spawned from collection
          fromCollection: true,
          // Reset age if it exists
          age: 0
        };
        
        (window as any).spawnFish(newFish);
        toast('Fish spawned in tank!', false);
        return true;
      }
      
      return false;
    } catch (error) {
      console.error('Error spawning fish:', error);
      toast('Failed to spawn fish', true);
      return false;
    }
  }

  /**
   * Start the process of renaming a fish
   */
  private startRenamingFish(fishId: string, nameElement: HTMLElement): void {
    const savedFish = this.getSavedFish();
    const fish = savedFish.find(f => f.id === fishId);
    if (!fish) return;
    
    const currentName = fish.name || '';
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentName;
    input.className = 'fish-name-input';
    input.style.width = `${Math.max(100, currentName.length * 8)}px`;
    
    // Replace the name with an input field
    nameElement.replaceWith(input);
    input.focus();
    input.select();
    
    // Track if we're already handling a submit to prevent duplicates
    let isSubmitting = false;
    
    // Handle input submission
    const handleSubmit = () => {
      if (isSubmitting) return;
      isSubmitting = true;
      
      const newName = input.value.trim();
      if (newName && newName !== currentName) {
        this.renameFish(fishId, newName);
      } else {
        // Revert to original name if empty or unchanged
        const span = document.createElement('span');
        span.className = 'name editable';
        span.setAttribute('data-fish-id', fishId);
        span.textContent = currentName;
        span.title = 'Click to rename';
        input.replaceWith(span);
      }
      
      setTimeout(() => { isSubmitting = false; }, 100);
    };
    
    // Handle key events
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        input.removeEventListener('blur', handleSubmit);
        handleSubmit();
        setTimeout(() => {
          input.addEventListener('blur', handleSubmit);
        }, 0);
      } else if (e.key === 'Escape') {
        const span = document.createElement('span');
        span.className = 'name editable';
        span.setAttribute('data-fish-id', fishId);
        span.textContent = currentName;
        span.title = 'Click to rename';
        input.replaceWith(span);
      }
    });
    
    // Add blur handler
    input.addEventListener('blur', handleSubmit);
  }

  /**
   * Remove a fish from the collection
   */
  private removeFish(fishId: string): boolean {
    console.log('removeFish called with ID:', fishId);
    try {
      const savedFish = this.getSavedFish();
      const fishIndex = savedFish.findIndex(fish => fish.id === fishId);
      
      if (fishIndex === -1) {
        console.log('Fish not found in collection');
        return false;
      }
      
      // Create a new array without the fish to be removed
      const updatedFish = savedFish.filter(fish => fish.id !== fishId);
      
      // Update game state if available
      if ((window as any).gameState) {
        (window as any).gameState.updateState((state: any) => ({
          ...state,
          fishCollection: updatedFish
        }));
        (window as any).gameState.save();
      }
      
      // Update localStorage as fallback
      localStorage.setItem('caroles_reef_saved_fish', JSON.stringify(updatedFish));
      
      // Remove the row from the DOM with animation
      const row = this.panel?.querySelector(`tr[data-fish-id="${fishId}"]`);
      if (row) {
        // Add fade-out effect
        (row as HTMLElement).style.transition = 'opacity 0.3s';
        (row as HTMLElement).style.opacity = '0';
        
        // Remove from DOM after animation completes
        setTimeout(() => {
          row.remove();
          
          // Update the fish count in the header if it exists
          const countElement = this.panel?.querySelector('h3 span');
          if (countElement) {
            countElement.textContent = `(${updatedFish.length} fish)`;
          }
          
          // If no fish left, close the panel
          if (updatedFish.length === 0 && this.panel) {
            this.hide();
          }
        }, 300);
      }
      
      toast('Fish removed from collection', false);
      return true;
    } catch (error) {
      console.error('Error removing fish:', error);
      toast('Failed to remove fish', true);
      return false;
    }
  }
    } catch (error) {
      console.error('Error removing fish:', error);
      toast('Failed to remove fish', true);
      return false;
    }
  }
  

  
  /**
   * Start renaming a fish
   */
  private startRenamingFish(fishId: string, nameElement: HTMLElement): void {
    const savedFish = this.getSavedFish();
    const fish = savedFish.find(f => f.id === fishId);
    if (!fish) return;
    
    const currentName = fish.name || '';
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentName;
    input.className = 'fish-name-input';
    input.style.width = `${Math.max(100, currentName.length * 8)}px`;
    
    // Replace the name with an input field
    nameElement.replaceWith(input);
    input.focus();
    
    // Select all text in the input
    input.select();
    
    // Track if we're already handling a submit to prevent duplicates
    let isSubmitting = false;
    
    // Handle input submission
    const handleSubmit = () => {
      // Prevent multiple submissions
      if (isSubmitting) return;
      isSubmitting = true;
      
      const newName = input.value.trim();
      if (newName && newName !== currentName) {
        this.renameFish(fishId, newName);
      } else {
        // Revert to original name if empty or unchanged
        const span = document.createElement('span');
        span.className = 'name editable';
        span.setAttribute('data-fish-id', fishId);
        span.textContent = currentName;
        span.title = 'Click to rename';
        input.replaceWith(span);
      }
      
      // Reset the flag after a short delay
      setTimeout(() => { isSubmitting = false; }, 100);
    };
    
    // Handle Enter key
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        // Remove the blur handler temporarily to prevent duplicate submission
        input.removeEventListener('blur', handleSubmit);
        handleSubmit();
        // Re-add the blur handler after a short delay
        setTimeout(() => {
          input.addEventListener('blur', handleSubmit);
        }, 0);
      } else if (e.key === 'Escape') {
        const span = document.createElement('span');
        span.className = 'name editable';
        span.setAttribute('data-fish-id', fishId);
        span.textContent = currentName;
        span.title = 'Click to rename';
        input.replaceWith(span);
      }
    });
    
    // Add blur handler
    input.addEventListener('blur', handleSubmit);
  }
  
  /**
   * Rename a fish in the collection and update all references
   */
  private renameFish(fishId: string, newName: string): boolean {
    try {
      const savedFish = this.getSavedFish();
      const fishIndex = savedFish.findIndex(f => f.id === fishId);
      
      if (fishIndex === -1) return false;
      
      // Get the original fish data
      const fishData = savedFish[fishIndex];
      const originalId = fishData.fishData.originalId || fishData.fishData.id;
      
      // Update the fish name in the collection
      fishData.name = newName;
      fishData.fishData.name = newName;
      
      // Save back to localStorage
      localStorage.setItem('caroles_reef_saved_fish', JSON.stringify(savedFish));
      
      // Update the fish in the tank if it exists
      try {
        const env = (window as any).env;
        if (env && Array.isArray(env.fish)) {
          // Find the fish in the tank by originalId or id
          const tankFish = env.fish.find((f: any) => 
            f.originalId === originalId || f.id === originalId || f.id === fishId
          );
          
          if (tankFish) {
            // Update the fish name in the tank
            tankFish.name = newName;
            
            // If the fish card is open for this fish, update its name
            const fishCard = document.getElementById('fishCard');
            if (fishCard && fishCard.style.display === 'block') {
              const nameElement = fishCard.querySelector('#fc-name');
              if (nameElement) {
                nameElement.textContent = newName || 'Unnamed Fish';
              }
              
              // Also update the input field if it's currently being edited
              const inputElement = fishCard.querySelector('input[type="text"]') as HTMLInputElement;
              if (inputElement && inputElement.id === 'renameFish') {
                inputElement.value = newName;
              }
            }
          }
        }
      } catch (error) {
        console.error('Error updating fish in tank:', error);
      }
      
      // Update the UI
      this.refreshCollection();
      
      // Show success message
      toast('Fish renamed successfully');
      
      return true;
    } catch (error) {
      console.error('Error renaming fish:', error);
      toast('Failed to rename fish', true);
      return false;
    }
  }
  
  
  /**
   * Save a fish to the collection
   */
  public async saveFish(fishData: any, name: string = ''): Promise<SavedFish | null> {
    try {
      console.log('[FishCollection] saveFish called with data:', { 
        fishData: { ...fishData, id: fishData.id || 'new-fish' },
        name
      });
      
      // Generate a new ID if one doesn't exist
      const fishId = fishData.id || `fish_${Date.now()}`;
      
      // Ensure we have a valid game state
      const gameState = (window as any).gameState;
      if (!gameState) {
        console.error('gameState not available');
        return null;
      }
      
      // Get current state immutably
      const currentState = gameState.getState() || {};
      const currentFishCollection = Array.isArray(currentState.fishCollection) 
        ? [...currentState.fishCollection] 
        : [];
      
      console.log('[FishCollection] Current state before update:', {
        fishCount: currentFishCollection.length,
        fishIds: currentFishCollection.map((f: any) => f.id)
      });
      
      // Create the fish data object with all required properties
      const now = new Date().toISOString();
      const fishToSave = {
        ...fishData,
        id: fishId,
        name: name || fishData.name || `Fish ${currentFishCollection.length + 1}`,
        saveDate: now,
        species: fishData.species || 'unknown',
        generation: fishData.generation || 1,
        timestamp: fishData.timestamp || Date.now()
      };

      // Create the saved fish item with proper typing
      const savedFishItem: SavedFish = {
        id: fishId,
        name: fishToSave.name,
        saveDate: now,
        fishData: fishToSave,
        species: fishToSave.species,
        rarity: fishToSave.rarityGene ? `Tier ${fishToSave.rarityGene}` : 'Common',
        generation: fishToSave.generation,
        timestamp: fishToSave.timestamp
      };

      console.log('[FishCollection] Saving fish:', {
        fishId,
        name: savedFishItem.name,
        species: savedFishItem.species,
        generation: savedFishItem.generation
      });

      // Find if this fish already exists
      const existingIndex = currentFishCollection.findIndex((fish: any) => {
        // Match by ID
        if (fish.id === fishId) return true;
        
        // Match by originalId if present
        const fishOriginalId = fish.fishData?.originalId || fish.fishData?.id;
        const newFishOriginalId = fishData.originalId || fishData.id;
        
        return fishOriginalId && newFishOriginalId && fishOriginalId === newFishOriginalId;
      });

      // Update or add the fish
      let updatedCollection;
      if (existingIndex >= 0) {
        updatedCollection = [
          ...currentFishCollection.slice(0, existingIndex),
          savedFishItem,
          ...currentFishCollection.slice(existingIndex + 1)
        ];
        console.log(`[FishCollection] Updated existing fish at index ${existingIndex}`);
      } else {
        updatedCollection = [...currentFishCollection, savedFishItem];
        console.log(`[FishCollection] Added new fish, total fish: ${updatedCollection.length}`);
      }

      // First, update the game state with the new collection
      console.log('[FishCollection] Updating game state with new fish collection');
      
      // Use a simple object update to ensure we don't have any issues with the updater function
      gameState.updateState({
        fishCollection: updatedCollection,
        // Also update the fish array for backward compatibility
        fish: updatedCollection
      });
      
      console.log('[FishCollection] Game state update requested, saving...');
      
      try {
        // Save the state
        await gameState.save();
        console.log('[FishCollection] Game state saved successfully');
        
        // Get the current state to verify
        const currentState = gameState.getState();
        const currentFish = currentState.fishCollection || currentState.fish || [];
        
        console.log('[FishCollection] Current state after save:', {
          fishCount: currentFish.length,
          fishIds: currentFish.map((f: any) => f?.id || 'no-id'),
          stateKeys: Object.keys(currentState)
        });
        
        // Always refresh the collection to ensure UI is in sync
        console.log('[FishCollection] Forcing UI refresh');
        this.refreshCollection();
        
        console.log('[FishCollection] Fish saved successfully');
        return savedFishItem;
      } catch (error) {
        console.error('[FishCollection] Error saving game state:', error);
        throw error; // Let the outer catch handle this
      }
    } catch (error) {
      console.error('[FishCollection] Error saving fish to collection:', error);
      toast('Failed to save fish to collection', true);
      return null;
    }
  }

  /**
   * Spawn a fish from saved data into the tank
   * @param fishData The fish data to spawn
   * @returns boolean indicating success or failure
   */
  public async spawnFishFromData(fishData: any): Promise<boolean> {
    console.groupCollapsed('[FishCollection] Spawning fish from data');
    console.log('Raw fish data:', JSON.parse(JSON.stringify(fishData)));
    
    try {
      // Import the validator
      const gameDataValidator = await import('../utils/gameDataValidator');
      
      // Extract the actual fish data if it's nested in a fishData property
      const rawFishData = fishData.fishData || fishData;
      console.log('Raw fish data before validation:', JSON.parse(JSON.stringify(rawFishData)));
      
      // Get current timestamp for validation
      const timestamp = Math.floor(Date.now() / 1000);
      console.log('Using timestamp for validation:', timestamp);
      
      // Validate and transform the fish data first
      console.log('Validating fish data...');
      const fishToSpawn = gameDataValidator.default.validateAndTransformFish(
        rawFishData,
        timestamp
      );
      
      if (!fishToSpawn) {
        console.error('Invalid fish data after validation');
        toast('Error: Could not create fish (invalid data)', true);
        return false;
      }
      
      console.log('Validated fish data:', JSON.parse(JSON.stringify(fishToSpawn)));
      console.log('Fish Y-coordinate after validation:', fishToSpawn.y);
      
      // Get the current window dimensions
      const W = window.innerWidth;
      
      // Create a new fish object with validated data
      const newFish: TankFish = {
        id: fishToSpawn.id || `fish-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        x: rand(40, W - 40),
        y: fishToSpawn.y || 160, // Ensure y is defined
        vx: rand(-30, 30),
        vy: rand(-30, 30),
        dir: rand(0, Math.PI * 2),
        state: 'wander',
        lastUpdated: Date.now(),
        // Copy all validated fish data
        ...fishToSpawn,
        // Ensure required properties are set
        birthTime: Math.floor(Date.now() / 1000),
        _maxAge: computeMaxAgeSeconds(fishToSpawn.constitution || 5),
        // Reset any state that shouldn't be copied
        _mateId: null,
        _ritualTimer: 0,
        _breedCd: 0,
        dead: false
      };
      
      console.log('Created new fish:', newFish);
      
      // Update the game state with the new fish
      console.log('Updating game state with new fish');
      gameState.updateState(state => {
        const tankFish = state.tank?.fish || [];
        const newFishCount = tankFish.length + 1;
        console.log(`Current tank fish count: ${newFishCount}`);
        
        // Update the fish count in the UI
        const popEl = document.getElementById('pop');
        if (popEl) {
          popEl.textContent = `Fish: ${newFishCount}`;
        }
        
        return {
          ...state,
          tank: {
            ...state.tank,
            fish: [...tankFish, newFish],
            lastUpdated: Date.now()
          }
        };
      });
      
      toast('Fish added to tank!', false);
      console.groupEnd();
      return true;
      
    } catch (error: any) {
      const errorMsg = `Failed to add fish to tank: ${error?.message || 'Unknown error'}`;
      console.error('[FishCollection] Error spawning fish:', error);
      toast(errorMsg, true);
    } finally {
      console.groupEnd();
    }
  }
}

// Create and export a singleton instance
const fishCollection = new FishCollection();

// Make it globally available
if (typeof window !== 'undefined') {
  (window as any).fishCollection = fishCollection;
}

export { fishCollection };
