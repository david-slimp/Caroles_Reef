# Fire Structure - planning and idea

# The target layout (best-of-both, TS-ready)

```
/src
  main.ts                      // bootstraps: canvas, state store, loaders, loop, UI wiring

  /core                        // engine-ish glue (no game rules, no DOM)
    canvas.ts                  // DPR, resize, exports ctx, W, H
    loop.ts                    // rAF, dt, pause, timeScale
    input.ts                   // mouse/keys, high-level intents (click, dragStart, hotkeys)
    events.ts                  // tiny event bus (pub/sub) used across UI/systems

  /config
    constants.ts               // MAX_FISH, limits, balances
    keys.ts                    // keybinds
    themes.ts                  // theme config only (no drawing)

  /state                       // the single source of truth (data only)
    store.ts                   // appState (fish[], pellets[], decors[], gen, discovered, mode, theme, time, paused)
    selectors.ts               // pure derived reads (isAdult, nearDecorType, counts)
    actions.ts                 // tiny, typed “mutations” (addFish, removePellet, setTheme, etc.)
    types.ts                   // core domain types used *everywhere*

  /entities                    // what exists in the world (data shape + factory)
    creature.ts                // base creature instance type (id, pos, age, size, genes, phenotype, flags)
    fish.ts                    // Fish-specific defaults/factory (uses base Creature)
    pellet.ts
    decor.ts
    bubbles.ts

  /genetics                    // big pillar: inheritance → genes → phenotype
    genome.ts                  // gene representation, allele types, RNG helpers
    traits.ts                  // trait definitions (shared across species)
    phenotype.ts               // map genes → visual/behavioral phenotypes
    breeding.ts                // breed(a,b) → offspring[], cooldown helpers
    rarity.ts                  // shiny/rarity rolls & math

  /systems                     // per-tick logic; stateless functions (state, dt) → state
    aiMovement.ts              // targeting, velocity, bounds, eat pellets
    breedingSystem.ts          // mate proximity, spawn babies, set cooldowns
    lifecycle.ts               // aging/size growth rules, despawn unless favorite
    feeding.ts                 // pellet gravity, ground settle
    bubblesSystem.ts           // bubble updates
    update.ts                  // master update() that calls all systems in order

  /engine                      // optional performance helpers (no game rules)
    spatial/
      quadtree.ts              // neighbor queries for food/mates/hiding/breeding spots
      index.ts
    math.ts                    // clamp, rand, randi, etc. (used across modules)

  /render                      // draw-only, pure functions of state + ctx
    background.ts
    decorRenderer.ts
    pelletsRenderer.ts
    bubblesRenderer.ts
    creatureRenderers/
      fishRenderer.ts          // per-species renderer (fish)
      // future: seahorseRenderer.ts, shrimpRenderer.ts, mermaidRenderer.ts
    draw.ts                    // master draw() in correct z-order

  /audio                       // Howler integration
    bus.ts                     // master/music/sfx buses, volume/ducking
    sfx.ts                     // sound registry (ids → file paths, categories)
    audioManager.ts            // playSfx('eat'), playMusic('dusk'), preloading

  /ui                          // DOM-only; translates user intents to actions/events
    panels/
      decorPanel.ts
      themePanel.ts
      dexPanel.ts
      settingsPanel.ts         // includes “Re-read creatures” + Save/Load buttons
    fishCard.ts
    toast.ts
    controls.ts                // wire buttons/sliders (mode, timeSpeed, pause)
    hotkeys.ts                 // 'f' feed etc.

  /data                        // data-driven content (loaded at runtime)
    /creatures                 // one JSON per species (schema-validated)
      fish.json
      seahorse.json
      shrimp.json
      mermaid.json
    /traits
      traits.json              // shared trait catalogs (patterns, fins, eyes…)
    /manifests
      creatures.manifest.json  // authoritative list of species JSONs to load (dev: can be regenerated)
    /schemas                   // JSON Schemas (and TS types generated from them)
      creature.schema.json
      traits.schema.json

  /data-loaders                // runtime loading & validation for JSON packs
    registry.ts                // CreatureRegistry (species metadata, factories, render hooks)
    loader.ts                  // load(manifest) → registry; supports reload()
    schema.ts                  // zod/valibot validators; narrow to TS types safely

  /dex                         // discovery/encyclopedia logic (data only)
    index.ts                   // trackDiscovery, queries, counters

  /persistence                 // save/load with versioning
    serialize.ts               // state → SaveBlob (strip ephemeral)
    deserialize.ts             // SaveBlob → state; applies migrations
    storage.ts                 // localStorage wrapper; slots; timestamps
    migrations.ts              // v1→v2 transforms when structures change
    types.ts                   // SaveBlob type with version tag

  /features                    // small, opt-in feature modules as the game grows
    // e.g., achievements, quests, screenshot share, etc.

  /types                       // shared, global utility types
    index.d.ts                 // (ambient types if needed)
```

```
/public                      // served as-is (Vite default; not bundled)
  /audio                     // .mp3/.ogg for Howler (mirrors /audio/sfx ids)
  /images                    // static image assets
  /data                      // (optional) if you prefer raw JSON to be fetched directly

/docs                        # Project documentation
  ARCHITECTURE.md            # High-level architecture decisions and data flow
  DEVELOPMENT.md             # Setup and development workflow
  TOOLING.md                 # Development tools and their configuration
  DEPLOYMENT.md              # Build and deployment instructions
  CONTRIBUTING.md            # Guidelines for contributors
  CHANGELOG.md               # Release notes and version history
  /diagrams                  # Architecture and flow diagrams
    component-diagram.puml   # PlantUML component diagram
    data-flow.puml           # Data flow diagram

/tests                       # Test suites (using Vitest)
  /unit                      # Unit tests
    /genetics
      breeding.spec.ts
      traits.spec.ts
    /systems
      movement.spec.ts
      breeding.spec.ts
  /integration               # Integration tests
    save-load.spec.ts
    creature-lifecycle.spec.ts
  /e2e                       # End-to-end tests (if needed)
    basic-gameplay.spec.ts
  /__snapshots__             # Test snapshots
  setup.ts                   # Test setup and global mocks

# Configuration Files
.eslintrc.json               # ESLint configuration
.prettierrc                  # Prettier code formatting rules
.stylelintrc.json            # CSS/Style linting
.gitignore                   # Git ignore rules
.editorconfig                # Editor configuration
.nvmrc                       # Node.js version
.vscode/                     # VS Code settings
  settings.json
  extensions.json
  launch.json

# Build & Tooling
vite.config.ts               # Vite configuration
vitest.config.ts             # Vitest configuration
babel.config.js              # Babel configuration (if needed)
postcss.config.js            # PostCSS configuration
husky/                       # Git hooks
  pre-commit                # Runs linting and tests before commit
  commit-msg                # Validates commit messages

# CI/CD
.github/
  workflows/
    ci.yml                  # GitHub Actions CI workflow
    release.yml             # Release automation
  dependabot.yml           # Dependency updates

# Environment Files
.env                        # Default environment variables
.env.development            # Development overrides
.env.production             # Production configuration
.env.test                   # Test environment

# TypeScript
/typedoc.json               # TypeDoc configuration
tsconfig.json               # TypeScript configuration
tsconfig.node.json          # Node-specific TS config
```

---

## Why this works (mapped to your goals)

* **Data-driven creatures (drop-in JSON):**

  * Put each species in `/data/creatures/*.json` and register via `/data/manifests/creatures.manifest.json`.
  * `/data-loaders/loader.ts` fetches & validates (via `schema.ts`), pushes into a **CreatureRegistry** that exposes:

    * species metadata (display name, allowed traits),
    * a factory (species defaults → `Creature`),
    * an optional renderer hook (points to `/render/creatureRenderers/*Renderer.ts`).
  * The “Re-read creatures dir” button simply calls `loader.reload()`, which refetches the manifest + JSONs and updates the registry (dev UX). In production, you can rebuild the manifest or serve an endpoint that lists available species.

* **Genetics/phenotype first-class:**

  * `genome.ts`, `traits.ts`, `phenotype.ts`, `breeding.ts` sit together and are testable in isolation.
  * Expanding non-visual traits (e.g., aggression, camouflage, fertility) just extends `traits.ts` + phenotype mapping. Visuals stay inside renderers.

* **Performance via spatial queries:**

  * `/engine/spatial/quadtree.ts` gives you O(log n) neighbor lookups for food/mates/hiding/breeding spots. Systems receive a spatial index snapshot per tick.

* **Clean decoupling:**

  * **render/** never mutates state (pure draw).
  * **systems/** never touch DOM or Howler directly; they emit intents on `/core/events.ts` (e.g., “eat” → UI can toast; audio can playSfx).
  * **ui/** only manipulates DOM and calls `actions.ts` or publishes events.

* **Audio (Howler):**

  * `audioManager.ts` centralizes SFX/music, with buses (master/music/sfx) and ducking. UI or events trigger `playSfx('eat')`, `playMusic('dusk')`.

* **Save/Load & migrations:**

  * `persistence/serialize.ts` strips ephemeral fields (velocities, caches).
  * Version every save; `migrations.ts` upgrades old saves when traits/species evolve.

* **TypeScript & tests:**

  * Everything typed at the module seam; genetics/loader/serialization have unit tests.
  * JSON validation with zod/valibot ensures malformed packs don’t crash the game.

* **Small and modular growth:**

  * New creature = add JSON + (optional) renderer file; no ripple edits.
  * New searchable object (e.g., anemone breeding spot) = add entity + register to spatial index; systems query by tag.

---

## Practical notes & tips

* **Manifest vs. direct folder reads:** browsers can’t list local dirs. Use:

  * a curated `creatures.manifest.json` you can edit and “Re-read” at runtime, **or**
  * in dev with Vite: `import.meta.glob('/src/data/creatures/*.json', { eager: false })` to enumerate files; expose a `reload()` that re-imports. For production, prebuild a manifest.

* **Renderer plug points:** have the registry map `speciesId → renderer` so you can ship a default “ellipse fish” renderer and later override per species without touching core.

* **Events over coupling:** raise small events from systems (`events.emit('atePellet', f.id)`) and let UI/audio subscribe. Keeps systems clean and testable.

* **Testing pyramid:** prioritize genetics, phenotype mapping, breeding logic, loader validation, serialization/migrations, and spatial queries. Rendering can be smoke-tested (no throws) or via canvas snapshots if you want.

---
